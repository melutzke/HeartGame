<!DOCTYPE html>
<head>
<script type = "text/javascript" src="./pacemaker_map.js"></script>
<script type = "text/javascript">

var GAMESTATE_START = 0;
var GAMESTATE_GAMEPLAY = 1;
var GAMESTATE_OPTIONS = 2;
var GAMESTATE_CREDITS = 3;

var background = new Image();
var blocksize = 25;
var collectable_count = 0;
var char_left = new Image();
var char_left_jump = new Image();
var char_left_second = new Image();
var char_right = new Image();
var char_right_jump = new Image();
var char_right_second = new Image();
var x_check;
var y_check;
var collectable = new Array();

var debug = false;
var grid = false;

var fpsWave = 60;
var gameHeight = 600;
var gameWidth = 1200;
var is_chrome = navigator.userAgent.toLowerCase().indexOf('chrome') > -1;
var is_explorer = navigator.userAgent.toLowerCase().indexOf('msie') > -1;
var lastfps = 0;
var num_collisions = 0;
var platform_x_movement = 0;
var platforms = new Array();
var platform_update = 0;
var thisFrameFPS = 0;
var windowActive = true;
var splashImage = new Image();


char_right_jump.src = 		"./Images/bucky_right_jump.gif";
char_left_jump.src = 		"./Images/bucky_left_jump.gif";
char_right.src = 			"./Images/bucky_right.gif";
char_left.src = 			"./Images/bucky_left.gif";
char_right_second.src = 	"./Images/bucky_right_second.gif";
char_left_second.src = 		"./Images/bucky_left_second.gif";
background.src = 			"./Images/test_background.jpg";
splashImage.src = 			"./Images/splash_screen.png";

	// nice little piece of code that uses a browser's native
	// request animation frame function if it exists. If it doesn't,
	// it reverts back to setTimeout



(function() {
    var lastTime = 0;
    //var vendors = ['ms', 'moz', 'webkit', 'o'];
    var vendors = ['pie'];
    for(var x = 0; x < vendors.length && !window.requestAnimationFrame; ++x) {
        window.requestAnimationFrame = window[vendors[x]+'RequestAnimationFrame'];
        window.cancelRequestAnimationFrame = window[vendors[x]+
          'CancelRequestAnimationFrame'];
    } 
    if (!window.requestAnimationFrame)
        window.requestAnimationFrame = function(callback, element) {
            var currTime = new Date().getTime();
            var timeToCall = Math.max(0, 16 - (currTime - lastTime));
            //var id = window.setTimeout(function() { callback(currTime + timeToCall); }, 
            	var id = window.setTimeout(function() { callback(currTime + timeToCall); }, 
              16);
            lastTime = currTime + timeToCall;
            return id;
        };

    if (!window.cancelAnimationFrame)
        window.cancelAnimationFrame = function(id) {
            clearTimeout(id);
        };
}())



var fps = 60, now, lastUpdate = (new Date)*1 - 1, fpsControl = 1, x, y;

// The higher this value, the less the FPS will be affected by quick changes
// Setting this to 1 will show you the FPS of the last sampled frame only
var fpsFilter = 10;

function Player(x_pos, y_pos) {

	this.x = x_pos;
	this.last_x = 0;
	this.y = y_pos;
	this.distance_since_sprite_change = 0;
	this.x_speed = 0;		// speed in which bucky moves in the x direction initially (always 0 to start)
	this.y_speed = 0;		// speed in which bucky moves in the y direction initially (always 0 to start)
	this.state = 0;     	// types of actions, can be set up with constants
	this.x_dir = 0;			// direction (1:right, -1:left, 0:no movement)
	this.y_dir = 0;			// direction (1:up, -1:down, 0:no movement)
	this.speed = 5;			// speed (in pixels per frame)
	this.airtime = 0;		// time bucky has been in the air (used for falling)
	this.image = new Image();
	this.width = 20;		// collision width of bucky (so he overlaps things a bit)
	this.height = 40;		// collision height of bucky (so he overlaps things a bit)
	this.grounded = false;
	this.grounded_last_frame = false;
	this.jump_hold_toggle = false;
	this.dead = false;
	this.walk_switch = false;

	this.update = update;	// when this.update is called, perform the update() function
	this.detect_collision_platform = detect_collision_platform;


	////////////////////////////////////////////////////////////////////////////////////////// Player's update function
	function update(){

		this.last_x = this.x;
		this.y_dir = 0;
		this.x_dir = 0;

		if(this.dead && !this.deathAnimToggle){
			this.deathAnimToggle = true
			//this.x_speed = 0;
			//platform_update = 0;

			// death animation
			this.y_speed = 7;
			this.y_dir = -1;
			this.airtime = 0;

		}

		if(this.y > gameHeight){
			this.dead = true;
		}

		if(!this.dead){

			if(!Controller.space){
				this.jump_hold_toggle = false;
			}
			
			if(Controller.left){
				this.x_dir = -1;	
			}
			if(Controller.right){
				this.x_dir = 1;
			}
			if(Controller.space && (this.grounded || this.grounded_last_frame) && !this.jump_hold_toggle){
				this.y_dir = -1;
				this.y_speed = 9;
				this.jump_hold_toggle = true;
			}
			if(Controller.shift){
				this.x_speed = 5;
			} else {
				this.x_speed = 3;
			}
			if(!Controller.left && !Controller.right){
				this.x_dir = 0;
				this.x_speed = 0;
			}
		
		}
		
		new_y_speed = -1 * Math.floor(this.y_speed) + Math.pow(this.airtime, 2);

		if(new_y_speed > 0){
			this.y_dir = 1;
		} else {
			this.y_dir = -1;
		}

		if(this.y_speed > 5  && !this.grounded && !this.grounded_last_frame && !Controller.space  && this.y_dir == -1 && !this.deathAnimToggle){
			this.y_speed = 5;
			new_y_speed = 0;
		}

		if(new_y_speed * fpsControl > 20){
			this.y += 20;
		} else {
			this.y += new_y_speed * fpsControl;
		}

		

			//////////////////////////////////////////////////////////////////////////////////////////  DETERMINE IF TO MOVE SCREEN?
		if(this.x >= 450 && this.x_dir == 1){
			// move platforms
			platform_x_movement -= this.x_dir * this.x_speed*fpsControl;
			platform_update = -1 * this.x_dir * this.x_speed*fpsControl;
			update_platforms(platform_update);

			if(this.airtime < 0.2){
				this.distance_since_sprite_change += Math.floor(this.x_speed*fpsControl);
			}

		} else if(this.x<= 200 && this.x_dir == -1){
			// move platforms
			platform_x_movement -= this.x_dir * this.x_speed*fpsControl;
			platform_update = -1 * this.x_dir * this.x_speed*fpsControl;
			update_platforms(platform_update);

			if(this.airtime < 0.2){
				this.distance_since_sprite_change += this.x_speed*fpsControl;
			}

		} else {
			platform_update = 0;
			this.x += this.x_dir * this.x_speed*fpsControl;

			if(this.airtime < 0.2){
				this.distance_since_sprite_change += this.x_speed*fpsControl;
			}
		}

		if(this.y>gameHeight-this.height + 500){
			this.y=gameHeight-this.height + 500;
		}

		if(!this.collision){
			this.airtime += 0.12*fpsControl;
		} 

		// after position has been updated, detect platform collision issues and resolve them
		if(!this.dead){
			this.detect_collision_platform();
		}
		


		for(var i = 0; i<collectable.length; i++){
			if(distanceBetween(this, collectable[i]) < 30){
				collectable[i].hidden = true;
				collectable_count++;
				collectable.splice(i, 1);
			}
		}


		if(this.x_dir == 1 || this.x_dir == 0){
			if(this.airtime > 0.5){
				this.image = char_right_jump;
			} else {
				this.image = char_right;
			}
		} else if (this.x_dir == -1){
			if(this.airtime > 0.5){
				this.image = char_left_jump;
			} else {
				this.image = char_left;
			}
		}

			////////////////////////////////////////////////////////////////////////////////////////// DETERMINE IF TO TOGGLE SPRITE (FOR WALKING ANIM)
		if(this.distance_since_sprite_change >= 20){
			this.walk_switch = !this.walk_switch;
			this.distance_since_sprite_change = 0;
		}



		if(this.x_dir == 1 || this.x_dir == 0){
			if(this.walk_switch && this.airtime < 0.5){
				this.image = char_right_second;
			} else if (this.airtime < 0.5){
				this.image = char_right;
			} else {
				this.image = char_right_jump;
			}
		} else {
			if(this.walk_switch && this.airtime < 0.5){
				this.image = char_left_second;
			} else if(this.airtime < 0.5) {
				this.image = char_left;
			} else {
				this.image = char_left_jump;
			}
		}
	}


		////////////////////////////////////////////////////////////////////////////////////////// COLLISION WITH PLATFORMS
	function detect_collision_platform(){
		this.grounded_last_frame = this.grounded;
		this.grounded = false;

		var centerPlayerX = 0;
		var centerPlayerY = 0;
		var centerRectX = 0;
		var centerRectY = 0;
		var distanceX = 0;
		var distanceY = 0;
		var minDistanceX = 0;
		var minDistanceY = 0;
		var depthX = 0;
		var depthY = 0;

		for(var i = 0; i<platforms.length; i++){

			centerPlayerX = this.x + this.width/2 + 6;
			centerPlayerY = this.y + this.height/2;
			centerRectX = platforms[i].x + platforms[i].width/2;
			centerRectY = platforms[i].y + platforms[i].height/2;

			distanceX = centerPlayerX - centerRectX;
			distanceY = centerPlayerY - centerRectY;
			minDistanceX = this.width/2 + platforms[i].width/2;
			minDistanceY = this.height/2 + platforms[i].height/2;

			if(Math.abs(distanceX) >= minDistanceX || Math.abs(distanceY) >= minDistanceY){
				depthX = 0;
				depthY = 0;
			} else {
				depthX = distanceX > 0 ? minDistanceX - distanceX : -minDistanceX - distanceX;
				depthY = distanceY > 0 ? minDistanceY - distanceY : -minDistanceY - distanceY;
			}

			if(Math.abs(depthY) < Math.abs(depthX)){ // resolve y first if true
				this.y += depthY;
				if(depthY<0){
					this.airtime = 0;
					this.y_speed = 0;
					this.grounded = true;
					if(platforms[i].type == 4){
						this.dead = true;
						this.y += 20; // impale him a bit
					}
				} else {
					this.airtime = 3;
				}
			} else { // resolve x first if the first statement was false
				this.x += depthX;
				this.x_speed = 0;
			}
		}
	}
}

	////////////////////////////////////////////////////////////////////////////////////////// UPDATE PLATFORM X POS (makes screen movement work)
function update_platforms(x_change){
	for(i = 0; i<platforms.length; i++){
		platforms[i].x += x_change;
	}
}

		/////////////////////////////////////////////////////////////////////////////////GODDAMN AWESOME AS SHIT BUTTONS (not really)
function Button(x_pos, y_pos, b_width, b_height, b_text, b_ctx) {
	this.x = x_pos;
	this.y = y_pos;
	this.width = b_width;
	this.height = b_height;
	this.text = b_text;
	this.ctx = b_ctx;
	this.draw = draw;
	this.fill = "#E7D9C1";
	this.stroke = "#000000";
	this.clicked = clicked;

	function draw(){
		this.ctx.fillStyle = this.fill;
		this.ctx.strokeStyle = this.stroke;
		this.ctx.lineWidth   = 1;
		this.ctx.font = '20px Calibri';

		var textWidth = this.ctx.measureText(this.text).width;
		var textHeight = this.ctx.measureText(this.text).height;

		var textX = this.x + this.width/2 - textWidth/2;


    	this.ctx.fillRect(this.x, this.y, this.width, this.height);
    	this.ctx.strokeRect(this.x, this.y, this.width, this.height);

    	this.ctx.fillStyle = this.stroke;
    	this.ctx.fillText(this.text, textX, this.y + this.height/2 + 7);
	}

	function clicked(){
		return Controller.click_mouse_y <= this.y+this.height && Controller.click_mouse_y >= this.y
			&& Controller.click_mouse_x <= this.x+this.width && Controller.click_mouse_x >=this.x;
	}
}

function Control() {
	this.space = false;
	this.shift = false;
	this.left = false;
	this.right = false;
	this.up = false;
	this.down = false;
	this.mouse_left = false;
	this.mouse_right = false;
	this.mouse_middle = false;
	this.click_mouse_x = null;
	this.click_mouse_y = null;
	this.mouse_x = null;
	this.mouse_y = null;
}
		////////////////////////////////////////////////////////////////////////////////////////// PLATFORMS CLASS
function Platform(x, y, type) {
	this.x = x;
	this.y = y;
	this.type = type;
	this.image = new Image();
	this.image.src = "./Images/grass_tile.png";
	this.width = blocksize;
	this.height = blocksize;
}
		////////////////////////////////////////////////////////////////////////////////////////// COLLECTABLES CLASS
function Item(x, y) {
	this.x = x;
	this.y = y;
	this.image = new Image();
	this.image.src = "./Images/beer_mug.gif";
	this.width = blocksize;
	this.height = blocksize;
	this.hidden = false;
}

function onFocus(){
	windowActive = true;
}

function onBlur(){
	windowActive = false;
}
		////////////////////////////////////////////////////////////////////////////////////////// DISTANCE BETWEEN TWO OBJECTS
function distanceBetween(Object1, Object2){
	// return the distance between the centers of two objects
	return Math.sqrt(
				Math.pow(((Object1.x+.5*Object1.width)-(Object2.x+platform_x_movement+.5*Object2.width)),2)
			  + Math.pow(((Object1.y+.5*Object1.height)-(Object2.y+0.5*Object2.height)),2)
			  );
}
		////////////////////////////////////////////////////////////////////////////////////////// GAME CLASS
function Game(ctx, x_boundary, y_boundary, frame_delay){
	this.ctx = ctx;					// canvas context
	this.frame_delay = frame_delay;	// ms delay between drawing
	this.x_boundary = x_boundary;	// x-coord boundary
	this.y_boundary = y_boundary;	// y-coord boundary
	this.clearColor = "rgba(100, 100, 100, 0.01)";			// initial clear color is null
	this.state = GAMESTATE_START;
	this.resetGame = resetGame;
			////////////////////////////////////////////////////////////////////////////////////// RESET GAME
	function resetGame(){
		collectable_count = 0;
		collectable_count = 0;
		collectable = new Array();
		imageMap = null;
		lastfps = 0;
		platform_x_movement = 0;
		platforms = new Array();
		platform_update = 0;
		begin_game();
		clearTimeout(gametimeout);
	}
}

function screenClear(currentGame){ 
	ctx.fillStyle = currentGame.clearColor;
	ctx.fillRect(0, 0, currentGame.x_boundary, currentGame.y_boundary);
	return true;
}
		////////////////////////////////////////////////////////////////////////////////////////// AVOID THIS SHIT
function drawObject(drawableObject, ctx){
	ctx.drawImage(drawableObject.image, Math.round(drawableObject.x), Math.round(drawableObject.y));
	return true;
}

function page_load() {
	// this code adds an event listener for mouse scrolling, it will call the mouse_scroll function every time an event is throw (the mouse is scrolled)
	var mousewheelevt=(/Firefox/i.test(navigator.userAgent))? "DOMMouseScroll" : "mousewheel" //FF doesn't recognize mousewheel as of FF3.x 
	if (document.attachEvent) //if IE (and Opera depending on user setting)
		document.attachEvent("on"+mousewheelevt, function(e) {mouse_scroll(e)}, false);
	else if (document.addEventListener) //WC3 browsers
		document.addEventListener(mousewheelevt, function(e) {mouse_scroll(e)}, false);
	
	begin_game();	// Begin the game
}

function mouse_scroll(event) {
	var evt=window.event || event //equalize event object
	var delta=evt.detail? evt.detail*(-120) : evt.wheelDelta //check for detail first so Opera uses that instead of wheelDelta
	// delta now holds the amount that the wheel was scrolled
}

function mouse_move(event) {
	Controller.mouse_x = event.offsetX?(event.offsetX):event.pageX-document.getElementById("draw_canvas").offsetLeft;
	Controller.mouse_y = event.offsetY?(event.offsetY):event.pageY-document.getElementById("draw_canvas").offsetTop;
	
	// x and y now hold the position onscreen of the mouse after the mouse was moved
}

function mouse_press(event) {
	Controller.click_mouse_x = event.offsetX?(event.offsetX):event.pageX-document.getElementById("draw_canvas").offsetLeft;
	Controller.click_mouse_y = event.offsetY?(event.offsetY):event.pageY-document.getElementById("draw_canvas").offsetTop;
	
	// x and y now hold the position onscreen of the mouse click
}

	////////////////////////////////////////////////////////////////////////////////////////// KEY PRESSED DOWN
function key_event(event) {
	switch(event.keyCode){
		// space       32
		//          arrow wasd
		// leftarrow   37 65
		// rightarrow  39 68
		// uparrow     38 87
		// downarrow   40 83
		case 32:				Controller.space = true;	break;		// space
		case 16:				Controller.shift = true;	break;		// shift
		case 39: case 68:		Controller.right = true;	break;		// right
		case 37: case 65:		Controller.left = true;		break;		// left
		case 38: case 87:		Controller.up = true; 		break;		// up
		case 40: case 83:		Controller.down = true;		break;		// down
	}
}
	////////////////////////////////////////////////////////////////////////////////////////// KEY COMES BACK UP
function key_event_up(event) {
	switch(event.keyCode){
		// space       32
		//          arrow wasd
		// leftarrow   37 65
		// rightarrow  39 68
		// uparrow     38 87
		// downarrow   40 83
		case 32:				Controller.space = false;	break;		// space
		case 16:				Controller.shift = false;	break;		// shift
		case 39: case 68:		Controller.right = false;	break;		// right
		case 37: case 65:		Controller.left = false;	break;		// left
		case 38: case 87:		Controller.up = false; 		break;		// up
		case 40: case 83:		Controller.down = false;	break;		// down
	}
}

function mouse_up(event) {
	switch(event.which){
		case 1: Controller.mouse_left = false; break;
		case 2: Controller.mouse_middle = false; break;
		case 3: Controller.mouse_right = false; break;
	}
}


function mouse_down(event) {
	switch(event.which){
		case 1: Controller.mouse_left = true; break;
		case 2: Controller.mouse_middle = true; break;
		case 3: Controller.mouse_right = true; break;
	}
}

	////////////////////////////////////////////////////////////////////////////////////////// SETTING THINGS UP INITIALLY
function begin_game() {


var canvas = document.getElementById("draw_canvas");
ctx = canvas.getContext("2d");

Controller = new Control();
PlayerGame = new Game(ctx, gameWidth, gameHeight, 10);		// (context, x_boundary, y_boundary, ms_delay)
PlayerGame.clearColor = "rgb(135,206,235)";
CurrPlayer = new Player(50, 300);				// (x-position, y-position)

Grass = new Platform();
Grass.imageArray = new Array();
Grass.imageArray[0] = new Image();
Grass.imageArray[0].src = "./Images/grass_tile.png";
Grass.imageArray[1] = new Image();
Grass.imageArray[1].src = "./Images/grass_tile2.png";

Dirt = new Platform();
Dirt.imageArray = new Array();
Dirt.imageArray[0] = new Image();
Dirt.imageArray[0].src = "./Images/ground_tile.png";
Dirt.imageArray[1] = new Image();
Dirt.imageArray[1].src = "./Images/ground_tile2.png";

Block = new Platform();
Block2 = new Platform();
Block3 = new Platform();
Beer = new Item();

Spike = new Platform();
SpikeColumn = new Platform();
Beer.image.src = "./Images/beer_mug.png";

//Block.image.src = "platform_placeholder.gif";
Block.image.src 	  = "./Images/platform.png";
Block2.image.src 	  = "./Images/platform_only.png";
Block3.image.src 	  = "./Images/platform_underneath.png";
Spike.image.src 	  = "./Images/spike_pit.png";	
SpikeColumn.image.src = "./Images/spike_lower.png";

CurrPlayer.image.src  = "./Images/bucky_small.gif";
scorebar = new Image();
scorebar.src = "./Images/scorebar.jpg";

OptionsButton = new Button(500, 350, 100, 30, "Credz", ctx);
CreditsButton = new Button(500, 250, 100, 30, "Credz", ctx);
PlayButton = new Button(500, 450, 100, 30, "Play Game", ctx);
ResetButton = new Button(650, 10, 120, 30, "Reset Game", ctx);




	imageMap = new Array(map.length);

	for(i = 0; i<map.length; i++){
		imageMap[i] = new Array(map[0].length);
	}

	

	for(var i = 0; i<map.length; i++){
		for(var k = 0; k<map[i].length; k++){
			


			// This fucking terrible mess draws the tiles, it looks like shit due to auto-tiling. If we dont
			// do tiling this will literally be like 4 if statements


				if(map[i][k]==1){
					if(i-1>=0){
						if(map[i-1][k]==1){
							imageMap[i][k] = Dirt.imageArray[Math.floor(Math.random()*Dirt.imageArray.length)]
						} else {
							imageMap[i][k] = Grass.imageArray[Math.floor(Math.random()*Grass.imageArray.length)];
						}
					} else {
						imageMap[i][k] = Grass.imageArray[Math.floor(Math.random()*Grass.imageArray.length)];
					}
				}
				// handle blue platforms
				if(map[i][k]==2){
					if(i-1>0 && i+1<map.length){
						if(map[i-1][k]==2 || map[i+1][k]==2){
							if(map[i-1][k] != 2){
								imageMap[i][k] = Block.image;
							} else {
								imageMap[i][k] = Block3.image;
							}
						} else {
							imageMap[i][k] = Block2.image;
						}
					} else {
						imageMap[i][k] = Block3.image;
					}
				}
				// handle spikes and their tiling
				if(map[i][k]==4){
					if(i-1>=0){
						if(map[i-1][k]==4){
							imageMap[i][k] = SpikeColumn.image;
						} else {
							imageMap[i][k] = Spike.image;
						}
					} else {
						imageMap[i][k] = Spike.image;
					}
				}
			
		if(imageMap[i][k] == undefined) imageMap[i][k] = null;
		}
	}

	////////////////////////////////////////////////////////////////////////////////////////// SEND COLLECTABLES TO AN ARRAY FROM MAP FILE
	for(var i = 0; i<map.length; i++){
		for(var k = 0; k<map[i].length; k++){
			if(map[i][k]!=0 && map[i][k]!=3 && map[i][k] != 5){
				platforms.push(new Platform(k*blocksize, i*blocksize, map[i][k]));
			}
			if(map[i][k]==3){
				collectable.push(new Item(k*blocksize, i*blocksize));
			}
		}
	}
	frame();
}

	////////////////////////////////////////////////////////////////////////////////////////// UP DRAWN TO SCREEN
function drawUI(context){

	var canvas = document.getElementById("draw_canvas");
	if(debug) {
		// draw debugging UI
		context.font = '15px Calibri';
		context.fillStyle = "rgb(240,240,240)";
		context.fillText("FPS-Avg: " 			+ fps.toFixed(0), 											120, 	20);
		context.fillText("FPS-Imm: " 			+ thisFrameFPS.toFixed(2), 									120, 	35);
		context.fillText("Collided: " 			+ CurrPlayer.grounded || CurrPlayer.grounded_last_frame, 	600, 	35);
		context.fillText("Dist-Since-Change: " 	+ CurrPlayer.distance_since_sprite_change.toFixed(2), 		600, 	20);
	} else {
		// draw normal UI
		context.drawImage(Beer.image, 15, 12);
		context.font = '25px Calibri';
		context.fillStyle = "rgb(240,240,240)";
		context.fillText(" x ", 37, 32);
		context.fillText("   " + collectable_count, 40, 33);
	}

	if(CurrPlayer.dead){
		context.font = '30px Calibri';
		context.fillText("You dead bro?",																230,	35);
	}
	if(document.activeElement.id != "draw_canvas" || !windowActive){
		context.fillStyle = "rgba(50,50,50,0.5)";
		context.fillRect(333, 247, 145, 50);
		context.fillStyle = "rgb(240,240,240)";
		context.font = '30px Calibri';
		context.fillText("Paused",																		350,	280);
	}
}


	///////////////////////////////////////////////////////////////////// ACTIONS TO DO BEFORE DRAWING (good place to update shit)
function frame(){

	if(Controller.down) CurrPlayer.dead = false;

		

	if(document.activeElement.id == "draw_canvas" && windowActive){
		///////////////////////////////////////////////////////////////////////////////////// UPDATE DAT BUCKY
		CurrPlayer.update();
	}
	
	screenClear(PlayerGame);

	gametimeout = setTimeout(frame, 5);
	draw_world();


	// IGNORE FRAME STUFF, it is used for accurate movement / fps counter
	thisFrameFPS = 1000 / ((now=new Date) - lastUpdate);
	if(thisFrameFPS < 10){
		thisFrameFPS = 60;
	}
	lastfps = fps;
	fps += (thisFrameFPS - fps) / fpsFilter;
	if(isNaN(fps)){
		// fps counter has glitched up, set it to a nice value
		fps = 60;
	}
	lastUpdate = now;
	fpsControl = 60/thisFrameFPS;
	fpsWave = 60/thisFrameFPS;
}

	////////////////////////////////////////////////////////////////////////////////////////// DRAW EVERYTHING
function draw_world() {  

	var canvas = document.getElementById("draw_canvas");


	if (PlayerGame.state == GAMESTATE_GAMEPLAY) {



		if(Controller.click_mouse_y <= ResetButton.y+ResetButton.height && Controller.click_mouse_y >= ResetButton.y
			&& Controller.click_mouse_x <= ResetButton.x+ResetButton.width && Controller.click_mouse_x >=ResetButton.x){
			PlayerGame.resetGame();
		}

		ctx = canvas.getContext("2d");
		ctx.drawImage(background, Math.round(platform_x_movement*(0.3)%background.width-background.width), 0);
		ctx.drawImage(background, Math.round(platform_x_movement*(0.3)%background.width), 0);
		ctx.drawImage(background, Math.round(platform_x_movement*(0.3)%background.width+background.width), 0);
	

			////////////////////////////////////////////////////////////////////////////////////////// DRAW EACH INDIVIDUAL TILE WHERE IT GOES
			for(var i = 0; i<map.length; i++){
				for(var k = 0; k<map[i].length; k++){
					if(imageMap[i][k] != null) ctx.drawImage(imageMap[i][k], k*blocksize+Math.floor(platform_x_movement), Math.floor(i*blocksize));
				}
			}

			////////////////////////////////////////////////////////////////////////////////////////// DRAW EACH COLLECTABLE
			for(var i = 0; i<collectable.length; i++){
				// handle booze collectables
				if(!collectable[i].hidden){
					ctx.drawImage(Beer.image, collectable[i].x+Math.floor(platform_x_movement), Math.floor(collectable[i].y));
				}
			}
		
			////////////////////////////////////////////////////////////////////////////////////////// DRAW DAT BUCKY
		drawObject(CurrPlayer, ctx);

			////////////////////////////////////////////////////////////////////////////////////////// DRAW UI
		drawUI(ctx);

			////////////////////////////////////////////////////////////////////////////////////////// DRAW RESET BUTTON
		ResetButton.draw();

			////////////////////////////////////////////////////////////////////////////////////////// DRAW SEXY GRID
		if(grid){
			blocksWidth = map[0].length;
			blocksHeight = map.length;
			for(var i = 0; i*blocksize<=blocksWidth*blocksize; i++){
				ctx.stokeStyle = "rgb(0,0,0)";
				ctx.beginPath();
				ctx.moveTo(0,i*blocksize);
				ctx.lineTo(blocksWidth*blocksize,i*blocksize);
				ctx.stroke();

				ctx.stokeStyle = "rgb(0,0,0)";
				ctx.beginPath();
				ctx.moveTo(i*blocksize+platform_x_movement%blocksize,0);
				ctx.lineTo(i*blocksize+platform_x_movement%blocksize,blocksHeight*blocksize);
				ctx.stroke();

				ctx.stokeStyle = "rgb(0,0,0)";
			}
		}

		////////////////////////////////////////////////////////////////////////////////////////// SPLASH SCREEN IF-BLOCK

	} /*else if(PlayerGame.state == GAMESTATE_CREDITS){

		ctx.drawImage(splashImage, -50, -50);
		PlayButton.draw();
		if(Controller.click_mouse_y <= PlayButton.y+PlayButton.height && Controller.click_mouse_y >= PlayButton.y
			&& Controller.click_mouse_x <= PlayButton.x+PlayButton.width && Controller.click_mouse_x >=PlayButton.x){

			PlayerGame.state = GAMEPLAY;

		}
	} */else if(PlayerGame.state == GAMESTATE_START){
		ctx.drawImage(splashImage, -50, -50);
		OptionsButton.draw();
		CreditsButton.draw();
		PlayButton.draw();
		
		if(PlayButton.clicked()){
			PlayerGame.state = GAMESTATE_GAMEPLAY;
		}
	}
}

////////////////////////////////////////////////////////////////////////////////////////// IGNORE THESE
window.addEventListener('keydown',key_event,true);
window.addEventListener('keyup',key_event_up,true);
window.addEventListener('mouseup', mouse_up, false);
window.addEventListener('mousedown', mouse_down, false);

window.onfocus = onFocus;
window.onblur = onBlur;
	
</script> 
</head>
<body style="overflow: hidden;"  onload="page_load()">

<canvas onmousemove="mouse_move(event)" onmousedown="mouse_press(event)" id="draw_canvas" width="1200" height="600" tabindex="1"></canvas>

<div id="fps" style="width: 50px;"></div><div id="ms" style="display: hidden;"></div>

<script type="text/javascript">
	gameCanvas = document.getElementById("draw_canvas");
  	document.getElementById("draw_canvas").focus();
</script>

</body>
</html>

